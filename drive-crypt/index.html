<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Drive crypt workshops</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">

    <style>
        .left {
            text-align: left;
        }
        .reveal ul {
            display: block;
        }
        .reveal ol {
            display: block;
        }

        .max600 {
            max-height: 600px !important;
        }

        .max550 {
            max-height: 550px !important;
        }

        .max500 {
            max-height: 500px !important;
        }

        .max450 {
            max-height: 450px !important;
        }

        .max300 {
            max-height: 300px !important;
        }

    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <section data-menu-title="Intro">
                <h1>Howto!</h1>
                <h3 class="r-fit-text">Effectively (auto-)nuke your storage?</h3>
                <h3>（╯°□°）╯︵(\ .o.)\</h3>

                <aside class="notes">
                    S - speaker mode // B - blank screen
                </aside>
            </section>

            <section data-menu-title="Preface">
                <h2>Why encrypt</h2>
                <p class="fragment fade-in-then-out">when you have nothing to hide? (づ｡◕‿‿◕｡)づ</p>
                <p class="fragment fade-in-then-semi-out">Develop a good practice</p>
                <p><span class="fragment fade-in-then-semi-out">At work: GDPR ?</span> <span
                        class="fragment fade-in-then-semi-out">Sensitive data?</span></p>
                <p class="fragment fade-in-then-semi-out">Selling your drive or removable storage?</p>
                <p class="fragment fade-in-then-semi-out">What if someone steals your laptop?</p>
                <p class="fragment">Or sometimes this happens...</p>

                <aside class="notes">
                    Good practice - cover window when parading naked around the house. Same analogy here. You never know
                    when someone is gonna use your data
                </aside>
            </section>

            <section data-menu-title="Oh, I didn't know officer">
                <video src="assets/Is_Chocola_Legal.mp4" controls></video>
            </section>

            <section>
                <h2>Workshop plans</h2>
                <ul>
                    <li>Software vs. hardware encryption</li>
                    <li>HDD sanitization</li>
                    <li>SSD low level</li>
                    <li>SSD sanitization</li>
                    <li>Special case: memory sticks</li>
                    <li>A few drive-related curiosities</li>
                    <li>Software encryption: Luks</li>
                    <li>Triggering: D-bus and other ideas</li>
                    <li>Creating an opus magnum</li>
                </ul>
            </section>

            <section>
                <h2>Before we begin</h2>
                <img src="assets/xkcd-security.png"/>
                <p class="fragment">We don't want that, do we?</p>
            </section>

            <section>
                <h2>Fortunately for us!</h2>
                <p class="r-fit-text">https://en.wikipedia.org/wiki/Key_disclosure_law#Poland</p>
                <blockquote class="small r-fit-text">
                    In relatively few known cases in which police or prosecutor requested cryptographic keys from those
                    formally accused and these requests were not fulfilled, no further consequences were imposed on the
                    accused. There's no specific law in this matter, as e.g. in the UK. It is generally assumed that the
                    Polish Criminal Procedure Code (Kodeks Postępowania Karnego Dz.U. 1997 nr 89 poz. 555.) provides
                    means of protecting against self-incrimination, including lack of penalization for refusing to
                    answer any question which would enable law enforcement agencies to obtain access to potential
                    evidence, which could be used against testifying person.
                </blockquote>
            </section>

        </section>

        <section>
            <h2>Prerequisites</h2>
            <p class="r-fit-text">apt install cryptsetup cryptsetup-nuke-password smartmontools wireshark-qt
                bruteforce-luks</p>
            <p class="r-fit-text">git clone https://github.com/openwall/john.git</p>
        </section>

        <section>
            <section>
                <h2 class="r-fit-text">Software vs. Hardware encryption</h2>
                <table>
                    <thead>
                    <tr>
                        <th>Property</th>
                        <th>Software</th>
                        <th>Hardware</th>
                    </tr>
                    </thead>

                    <tbody>
                    <tr>
                        <td>Transparent</td>
                        <td>X</td>
                        <td>X</td>
                    </tr>
                    <tr>
                        <td>Hardware-bound auth</td>
                        <td>option</td>
                        <td>X</td>
                    </tr>
                    <tr>
                        <td>Overhead</td>
                        <td>X</td>
                        <td>*</td>
                    </tr>
                    <tr>
                        <td>Fast termination</td>
                        <td>X</td>
                        <td>X</td>
                    </tr>
                    <tr>
                        <td>Auditable</td>
                        <td>X</td>
                        <td>¯\_(ツ)_/¯</td>
                    </tr>
                    </tbody>
                </table>

                <small>* - Hardware: non-legacy solutions</small>

                <aside class="notes">
                    SED == Self-encrypting drive<br/>
                    TPM - trusted platform module, hash from hardware, RNG, key storage<br/>
                    Pre-boot authentication<br/>
                    Attack vectors: HDD/SSD: key in memory whilst power-on. <br/>
                    Soft: key in memory<br/>
                    Both: brute force<br/>
                </aside>
            </section>

            <section>
                <h2>Erasure by crypto type</h2>
                <h3>Hardware</h3>
                <ul class="left">
                    <li>BLKDISCARD</li>
                    <li>ATA SECURE ERASE (ENHANCED)</li>
                    <li>PCIe/NVMe</li>
                    <li>SCSI SANITIZE</li>
                </ul>

                <h3>Software</h3>
                <ul>
                    <li>US DoD 5220.22-M and other wipe methodologies</li>
                    <li>Free space (HDD only, past files)</li>
                </ul>

                <aside class="notes">
                    Hardware == whole disk,<br/>
                    software == whole or single file
                </aside>
            </section>

            <section>
                <h2>When a file is deleted</h2>
                <p>It's just marked as so in filesystem &</p>
                <p>On HDD it can be now overwritten by the system</p>
                <p>On SSD - (╯°□°）╯︵ ┻━┻</p>
            </section>

        </section>

        <section>
            <section>
                <h2>HDD sanitization</h2>
                <ul>
                    <li>Blocks, sectors, LBA</li>
                    <li>Talking with controller</li>
                    <li>Manufacturer sanitization</li>
                    <li>Software shredding</li>
                </ul>

                <aside class="notes">
                    LBA == Logical block addressing
                    HDD == Hard Disk Drive
                    SSD == Solid
                </aside>
            </section>

            <section>
                <h2>TODO Blocks, sectors, LBA</h2>
                <b>TODO</b>
                <p>In a magnetic drive OS has the direct access to physical sectors</p>
                <p>That translates directly to filesystem</p>
            </section>

            <section>
                <h2>Controller stuff: HPA, DCO</h2>
                <p>Fun stuff you probably haven't heard off</p>
                <p>HPA == host protected area</p>
                <p>DCO == Device configuration overlay</p>

                <p>Those hide sectors from bios/efi, system and user</p>
                <p>(survives everything but secure erase)</p>

                <pre class="bash">
                    <code data-trim>
                        # Your OS may ignore this already
                        cat /sys/module/libata/parameters/ignore_hpa
                    </code>
                </pre>

            </section>

            <section>
                <h2 class="r-fit-text">Controller stuff: Hardware password</h2>
                <p>Master password == for IT admins, higher order*</p>
                <p>User password == self explanatory</p>
                <p>We'll be using <i>hdparm</i> for that</p>
                <small>*- depends on security mode (high or max), let me show you</small>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: set hardware password</h2>
                <p><u>Remember</u> and <u>double-check</u> the password otherwise you'll brick the drive</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        hdparm --user-master u --set-security-pass pass /dev/sda
                        # unplug drive, plug in again, notice that kernel throws read errors!
                        dmesg -c
                        # Notice, that drive now appears locked!
                        hdparm -I /dev/sda
                        # unlock the device
                        hdparm --user-master u --security-unlock pass /dev/sda
                        mount /dev/sda1 /mnt/something
                        dmesg -c
                        hdparm --user-master u --security-disable pass /dev/sda
                        # unplug, plug in again. Now there should be no password left
                        dmesg -c
                    </code>
                </pre>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: when drive is frozen</h2>
                <pre>
                    <code data-trim>
                        # Suspend and wake up
                        echo -n mem > /sys/power/state
                    </code>
                </pre>
                <p>or hotplug SATA</p>
                <p>(AHCI must be enabled for SATA hotplugging)</p>
            </section>

            <section>
                <h2>Manufacturer sanitization</h2>
                <p>Be warned, this takes time</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        # We need to set password first
                        $ hdparm --user-master u --security-set-pass pass /dev/sda

                        # Then wipe
                        $ hdparm --user-master u --security-erase-enhanced pass /dev/sda

                        $ hdparm --security-help

                        ATA Security Commands:
                         Most of these are VERY DANGEROUS (͡° ͜ʖ ͡°) and can destroy all of your data!
                         Due to bugs in older Linux kernels, use of these commands may even
                         trigger kernel segfaults or worse.  EXPERIMENT AT YOUR OWN RISK! ᕕ( ͡°ᴥ ͡°)ᕗ

                         --security-freeze           Freeze security settings until reset.

                         --security-set-pass PASSWD  Lock drive, using password PASSWD:
                                                          Use 'NULL' to set empty password.
                                                          Drive gets locked if user-passwd is selected.
                         --security-prompt-for-password   Prompt user to enter the drive password.

                         --security-unlock   PASSWD  Unlock drive.
                         --security-disable  PASSWD  Disable drive locking.
                         --security-erase    PASSWD  Erase a (locked) drive.
                         --security-erase-enhanced PASSWD   Enhanced-erase a (locked) drive.

                         The above four commands may optionally be preceded by these options:
                         --security-mode  LEVEL      Use LEVEL to select security level:
                                                          h   high security (default).
                                                          m   maximum security.
                         --user-master    WHICH      Use WHICH to choose password type:
                                                          u   user-password (default).
                                                          m   master-password
                    </code>
                </pre>
            </section>

            <section>
                <h2>Software shredding</h2>
                <p>As the OS has direct access to physical sectors we could just..</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        # -u; deallocate and remove file after overwriting
                        # -z; --zero; add a final overwrite with zeros to hide shredding
                        shred -zu /some/file
                    </code>
                </pre>
                <p class="r-fit-text">It's their own algorithm, described in sources. Self-tested with oscilloscope</p>
                <p class="r-fit-text">https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/shred.c#n626</p>
            </section>
        </section>


        <section>
            <section>
                <h2>SSD low level</h2>
                <ul>
                    <li>blocks, pages</li>
                    <li>FTL</li>
                    <li>GC process (P/E Cycle)</li>
                    <li>TRIM (SAS: UNMAP, PCIe: DEALLOCATE)</li>
                </ul>

                <aside class="notes">
                    FTL == Flash Translation Layer, i.e. controller
                </aside>
            </section>

            <section>
                <h2>How data is stored</h2>
                <p class="r-fit-text">Reads pages, erases blocks, writes to empty pages</p>
                <p>blocks: 256kB-4MB, pages: 2-32kB</p>
                <p>Typically 128 pages per block with 4kB page size</p>
                <img class="max300" src="assets/ssd_blocks_pages.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section>
                <h2>Flash Translation Layer</h2>
                <p>i.e. controller operations</p>
            </section>

            <section>
                <h2>Over-provisioning</h2>
                <p>Reserved for controller, rest available to host</p>
                <p class="fragment">Used for:</p>
                <p class="fragment">Garbage collection</p>
                <p class="fragment">Wear leveling</p>
                <p class="fragment">TRIM</p>
                <p class="fragment">Background manufacturer-specific tasks</p>
            </section>

            <section>
                <h2>Garbage collection</h2>
                <img src="assets/hdd_ssd_write_1.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section data-menu-title="Garbage collection 2">
                <h2>Garbage collection</h2>
                <img src="assets/hdd_ssd_write_2.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section data-menu-title="Garbage collection 3">
                <h2>Garbage collection</h2>
                <img src="assets/hdd_ssd_write_3.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section data-menu-title="TRIM">
                <img class="max600" src="assets/ssd_trim.png"/>
                <small>TRIM[2], an ATA/PCIe SSD GarbageCollect extension command</small>

                <aside class="notes">
                    Filesystem needs to support TRIM!
                </aside>
            </section>

        </section>

        <section>
            <section>
                <h2>SSD sanitization</h2>
                <ul>
                    <li>hdd methods ineffective (including degaussing)</li>
                    <li>dumping flash is easier(& cheaper) than magnetic</li>
                    <li>pcie/ata/scsi commands</li>
                    <li>BLKDISCARD / BLKSECDISCARD</li>
                </ul>
            </section>

            <section>
                <h2 class="r-fit-text">Do HDD Sanitization methods work well on SSDs?</h2>
                <ul>
                    <li>Degaussing? <span class="fragment">Nope</span></li>
                    <li>Single file overwrite? <span class="fragment">Nope</span></li>
                    <li>Multiple disk overwrites? <span class="fragment">Nope</span></li>
                </ul>
                <p class="fragment">
                    <img class="max300" src="assets/ssd_overwrite_recovery.png"/>
                    <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
                </p>
            </section>

            <section>
                <img class="max550" src="assets/passd.png"/>
                <span class="r-fit-text">IEEE Access, D. Lee et al. October 2020, Improving Write Performance Through Reliable Asynchronous Operation in Physically-Addressable SSD</span>
                <aside class="notes">
                    Patent publication by Google, discarded (first published 2011)
                    Now samsung is trying its best on the topic
                </aside>
            </section>

            <section data-menu-title="FPGA dumper">
                <img src="assets/fpga.png" class="max550"/>
                <p>Fpga flash dumper</p>
            </section>

            <section>
                <h2>TODO pcie/ata/scsi commands</h2>
                <b>TODO</b>
            </section>

            <section>
                <h2>TODO pcie/ata/scsi commands 2</h2>
                <b>TODO</b>
                <code>
                    smart,
                    nvme-cli,
                    hdparm
                </code>
            </section>

        </section>

        <section>
            <section>
                <h2 class="r-fit-text">Special flash case: memory sticks</h2>
                <p>Protocols</p>
                <p>Talking with controller?? <span class="fragment">Or not ;(</span></p>
            </section>

            <section>
                <h2>Protocols</h2>
                <p>Previously mass storages were using BOT (Bulk-only transport)</p>
                <p>Nowadays it was(should be?) superseded by UAS/UASP</p>
                <p>i.e. USB Attached SCSI (Protocol)</p>
                <p>SCSI == Small Computer System Interface ノ( ゜-゜ノ)</p>
            </section>

            <section>
                <h2>Hands on: first impression</h2>
                <p>Run these few commands, try <u>different</u> thumb drives</p>
                <pre>
                    <code data-trim data-noescape>
                        sudo dmesg -c
                        # plug in
                        sudo dmesg -c
                        lsusb
                        # example: Bus 004 Device 004: ID 13fe:5200 Kingston [...]
                        lsusb -d 13fe:5200 -v
                        hdparm -I /dev/sda  # Assuming sda was assigned
                        smartctl -a /dev/sda
                        # plug out
                        sudo dmesg -c
                    </code>
                </pre>
            </section>

            <section>
                <h2>Hands on: if first impressions were bad</h2>
                <p>change usb driver from uas to bot ;)</p>
                <pre>
                    <code data-trim data-noescape>
                        lsusb -t  # check driver here, usb_storage or uas
                        lsusb
                        # example: Bus 004 Device 007: ID 090c:1000 Silicon Motion [...]
                        echo "090c:1000:u" > /sys/module/usb_storage/parameters/quirks
                    </code>
                </pre>
                <p>And try again</p>
            </section>

            <section>
                <h2>Hands on: wireshark time</h2>
                <pre>
                    <code data-trim data-noescape>
                        sudo dmesg -c
                        # Requires relogging
                        sudo adduser $USER wireshark
                        sudo dpkg-reconfigure wireshark-common
                        modprobe usbmon
                        sudo setfacl -m u:$USER:r /dev/usbmon*
                        lsusb
                        # example: Bus 004 Device 004: ID 13fe:5200 Kingston [...]
                        # so then run capture on usbmon4
                        # ----> IMPORTANT: notice SCSI dumps !
                    </code>
                </pre>
            </section>

            <section>
                <h2>Summing up the USB stuff</h2>
                <p>Can we talk with flash controller?</p>
                <p><span class="fragment">Well yes</span> <span class="fragment">...but no ;/</span></p>
                <p class="fragment r-fit-text">Manufacturers smart & scsi is implementation is rather poor</p>
                <p class="fragment r-fit-text">Let me show you a few examples on different pendrives</p>
                <p class="fragment r-fit-text">Exception to the rule: SSD over USB sticks, i.e. SAT (USB SATA
                    bridge)</p>
                <small class="fragment">(Example: SanDisk Extreme Pro 128GB stick)</small>
            </section>
        </section>

        <section>
            <section>
                <h2>A few drive curiosities</h2>
                <p>Tech blogs giving shitty advice</p>
                <p>Boost HDD performance/p>
                <p>S.M.A.R.T. saving lives, kind of</p>
            </section>

            <section>
                <h2>Tech blogs giving shitty advice</h2>
                <p>Now you know some stuff</p>
                <p>Google: "howto securely erase SSD"</p>
                <p>Enjoy</p>
                <p class="fragment">(͡° ͜ʖ ͡°) <span class="fragment">(͡° ͜ʖ ͡°)</span> <span class="fragment">(͡° ͜ʖ ͡°)</span>
                    <span class="fragment">(͡° ͜ʖ ͡°)</span> <span class="fragment">(͡° ͜ʖ ͡°)</span></p>

            </section>

            <section>
                <h2>Boosting HDD seek time</h2>
                <h3>Db-admin secret ^_^</h3>
                <img class="max450" src="assets/header_overview.png"/>
            </section>

            <section>
                <h2>TODO S.M.A.R.T. saving lives</h2>
                <p>Plugged SSD-based pendrive into laptop</p>
                <p>Notice appeared!</p>

                TODO

                plasma5 notice, real life sample
                add link to driveBlaze article on smart params
            </section>
        </section>

        <section>
            <section>
                <aside class="notes">
                    @/etc/modprobe.d/more_loopz.conf:<br/>
                    options loop max_loop=123

                    luks2 - kernel keyring

                    https://en.wikipedia.org/wiki/Comparison_of_disk_encryption_software
                </aside>

                <h2>TODO Luks</h2>
                <pre>
1. luks header luks1 vs. luks2 // OKTETA view
2. create loop, cryptsetup luks1, dump header, erase, restore header
3. create luks1, restore master password from memory
4. create luks with key unlock
5. mention many unlocking possibilities - like ssh, pen during pre-boot, TPM
6. TPM, signed kernels ---> root of trust, otherwise someone might poison /boot
                </pre>
            </section>

            <section>
                <h2>Nuke it with predefined password :*</h2>
                <code data-trim data-noescape>
                    dpkg-reconfigure cryptsetup-nuke-password

                    cryptsetup luksHeaderBackup --header-backup-file luks_header.bin /dev/nvme0n1p3
                    file luks_header.bin
                    luks_header.bin: LUKS encrypted file, ver 2 [, , sha256] UUID: XXXXXXXXXXXXXXXXXXXXXXXXXX
                    cryptsetup luksDump luks_header.bin

                    luksHeaderRestore --header-backup-file luks_header.bin /dev/nvme0n1p3
                </code>
            </section>
        </section>

        <section>
            <section>
                <h2>Time to automate...</h2>
                <p>Dbus!</p>
                <p>Triggers</p>
            </section>

            <section>
                <h2>Dbus</h2>
                <b>TODO</b>
            </section>

            <section>
                <h2>Sample dbus client</h2>
                <small>https://github.com/rikkt0r/presentations/tree/main/drive-crypt</small>
                <pre>
                    <code data-trim data-noescape>
                        #!/usr/bin/python3

                        import dbus
                        from gi.repository import GLib
                        from dbus.mainloop.glib import DBusGMainLoop


                        keys = ["app_name", "replaces_id", "app_icon", "summary", "body", "actions", "hints", "expire_timeout"]


                        def print_notification(bus, message):
                            args = message.get_args_list()
                            if len(args) == 8:
                                notification = dict([(keys[i], args[i]) for i in range(8)])
                                print(f'{notification["app_name"]} :::: {notification["summary"]} - {notification["body"]}')
                            else:
                                print("Unparsable", args)


                        if __name__ == "__main__":
                            loop = DBusGMainLoop(set_as_default=True)
                            session_bus = dbus.SessionBus()
                            session_bus.add_match_string("type='method_call',interface='org.freedesktop.Notifications',member='Notify',eavesdrop=true")
                            session_bus.add_message_filter(print_notification)
                            GLib.MainLoop().run()
                    </code>
                </pre>
            </section>

            <section>
                <h2>Hands on: Your turn</h2>
                <p>Run script, notice what happens</p>
                <small>Side node: for final script we're gonna use SystemBus, not SessionBus</small>

            </section>

        </section>

        <section>
            <section>
                <h2>Wet dream of a crypto-nerd</h2>
                <p>Let's create YOUR opus magnum of cryptography</p>
                <p>(Well, without possible deniability)</p>
                <p class="fragment">why do this you ask?</p>
            </section>

            <section data-menu-title="FBI Raid">
                <img src="assets/fbi-open-up-fbi-meme.gif"/>
                <h2>Coz this happens..</h2>
            </section>

            <section data-menu-title="FBI Raid goes on">
                <img src="assets/fbi-swat.gif"/>
                <h2>.. and then that</h2>
                <h3>Gotta act fast ✌</h3>
            </section>

            <section>
                <h2>The master-plan</h2>
                <p>Choose your favourite sanitization methods</p>
                <p>Create luks on top of that</p>
                <p>Add a sprinkle of magic</p>
                <p>Call the police (´・ω・)っ由</p>
                <img src="assets/fbi-anime.gif"/>
            </section>

            <section>
                <h2>Open workshop</h2>
                <p>Creating opus magnum of crypto</p>
                <p>Remember - Be dual? triple? OCTA-SURE about wiping keys!</p>
                <img class="fragment fade-out" src="assets/fbi-fbi-typing.gif"/>
            </section>
        </section>

        <section>
            <h2>Over-the-top forensics</h2>
            <ol>
                <li>Arrive with liquid nitrogen and external battery PSU</li>
                <li>Stabilize power</li>
                <li>Freeze and dump RAM</li>
                <li>Attach write blocker to disk, dump</li>
                <li>Do forensics™ on disk clone</li>
            </ol>
        </section>

        <section data-menu-title="Tin foil hat ideas">
            <h2>TIN FOIL HAT IDEAS ┬─┬ ︵ /(.□. \）</h2>
            <ul>
                <li>always have a bootable pendrive containing memtest86 plugged-in. HDD/SSD has higher priority, so
                    that this
                    boots after disk sanitization
                </li>
                <li>For how long the key is recoverable from disk eeprom?</li>
                <li>Ram alive for ... TODO ... after powerdown ?</li>
            </ul>
        </section>

        <section>
            <h2>The end; &copy; rikkt0r</h2>
            <p>(づ｡◕‿‿◕｡)づ Bibliography</p>
            <ol>
                <li><a href="https://www.usenix.org/legacy/events/fast11/tech/full_papers/Wei.pdf" target="_blank">[Usenix]
                    Reliably Erasing Data From Flash-Based Solid State Drives</a></li>
                <li>https://www.techtarget.com/searchstorage/definition/TRIM</li>
                <li><a href="https://www.smartmontools.org/wiki/USB">SCSI/ATA/SATA -> USB adapter support</a></li>
                <li><a href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase">Kernel wiki - ATA Secure erase</a>
                </li>
                <li>manpages for: smartmontools, hdparm, nvme-cli</li>
                <li>Truly deniable: https://www.cl.cam.ac.uk/~rja14/Papers/stego-fs.pdf</li>
            </ol>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script src="plugin/menu/menu.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu ]
    });


</script>
</body>
</html>
