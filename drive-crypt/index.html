<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Drive crypt workshops</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">

    <style>
        .left {
            text-align: left;
        }
        .reveal ul {
            display: block;
        }
        .reveal ol {
            display: block;
        }

        .max600 {
            max-height: 600px !important;
        }

        .max550 {
            max-height: 550px !important;
        }

        .max500 {
            max-height: 500px !important;
        }

        .max450 {
            max-height: 450px !important;
        }

        .max300 {
            max-height: 300px !important;
        }

        .max100 {
            max-height: 100px !important;
        }

    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <section data-menu-title="Intro">
                <h1>Howto!</h1>
                <h3 class="r-fit-text">Effectively (auto-)nuke your storage?</h3>
                <h3>（╯°□°）╯︵(\ .o.)\</h3>

                <aside class="notes">
                    S - speaker mode // B - blank screen
                </aside>
            </section>

            <section data-menu-title="Preface">
                <h2>Why encrypt</h2>
                <p class="fragment fade-in-then-out">when you have nothing to hide? (づ｡◕‿‿◕｡)づ</p>
                <p class="fragment fade-in-then-semi-out">Develop a good practice</p>
                <p><span class="fragment fade-in-then-semi-out">At work: GDPR ?</span> <span
                        class="fragment fade-in-then-semi-out">Sensitive data?</span></p>
                <p class="fragment fade-in-then-semi-out">Selling your drive or removable storage?</p>
                <p class="fragment fade-in-then-semi-out">What if someone steals your laptop?</p>
                <p class="fragment">Or sometimes this happens...</p>

                <aside class="notes">
                    Good practice - cover window when parading naked around the house. Same analogy here. You never know
                    when someone is gonna use your data
                </aside>
            </section>

            <section data-menu-title="Oh, I didn't know officer">
                <video src="assets/Is_Chocola_Legal.mp4" controls></video>
            </section>

            <section>
                <h2>Workshop plans</h2>
                <ul>
                    <li>Software vs. hardware encryption</li>
                    <li>HDD sanitization</li>
                    <li>SSD low level</li>
                    <li>SSD sanitization</li>
                    <li>Special case: memory sticks</li>
                    <li>A few drive-related curiosities</li>
                    <li>Software encryption: Luks</li>
                    <li>Triggering: D-bus and other ideas</li>
                    <li>Creating an opus magnum</li>
                </ul>
            </section>

            <section>
                <h2>Before we begin</h2>
                <img src="assets/xkcd-security.png"/>
                <p class="fragment">We don't want that, do we?</p>
            </section>

            <section>
                <h2>Fortunately for us!</h2>
                <p class="r-fit-text">https://en.wikipedia.org/wiki/Key_disclosure_law#Poland</p>
                <blockquote class="small r-fit-text">
                    In relatively few known cases in which police or prosecutor requested cryptographic keys from those
                    formally accused and these requests were not fulfilled, no further consequences were imposed on the
                    accused. There's no specific law in this matter, as e.g. in the UK. It is generally assumed that the
                    Polish Criminal Procedure Code (Kodeks Postępowania Karnego Dz.U. 1997 nr 89 poz. 555.) provides
                    means of protecting against self-incrimination, including lack of penalization for refusing to
                    answer any question which would enable law enforcement agencies to obtain access to potential
                    evidence, which could be used against testifying person.
                </blockquote>
            </section>

        </section>

        <section>
            <h2>Prerequisites</h2>
            <p class="r-fit-text">apt install cryptsetup cryptsetup-nuke-password smartmontools wireshark-qt
                bruteforce-luks</p>
            <p class="r-fit-text">git clone https://github.com/cryptcoffee/skul</p>
        </section>

        <section>
            <section>
                <h2 class="r-fit-text">Software vs. Hardware encryption</h2>
                <table>
                    <thead>
                    <tr>
                        <th>Property</th>
                        <th>Software</th>
                        <th>Hardware</th>
                    </tr>
                    </thead>

                    <tbody>
                    <tr>
                        <td>Transparent</td>
                        <td>X</td>
                        <td>X</td>
                    </tr>
                    <tr>
                        <td>Hardware-bound auth</td>
                        <td>option</td>
                        <td>X</td>
                    </tr>
                    <tr>
                        <td>Overhead</td>
                        <td>X</td>
                        <td>*</td>
                    </tr>
                    <tr>
                        <td>Fast termination</td>
                        <td>X</td>
                        <td>X</td>
                    </tr>
                    <tr>
                        <td>Auditable</td>
                        <td>X</td>
                        <td>¯\_(ツ)_/¯</td>
                    </tr>
                    </tbody>
                </table>

                <small>* - Hardware: non-legacy solutions</small>

                <aside class="notes">
                    SED == Self-encrypting drive<br/>
                    TPM - trusted platform module, hash from hardware, RNG, key storage<br/>
                    Pre-boot authentication<br/>
                    Attack vectors: HDD/SSD: key in memory whilst power-on. <br/>
                    Soft: key in memory<br/>
                    Both: brute force, though hardware BF is tougher<br/>
                </aside>
            </section>

            <section>
                <h2>Erasure by crypto type</h2>
                <h3>Hardware</h3>
                <ul class="left">
                    <li>BLKDISCARD</li>
                    <li>ATA SECURE ERASE (ENHANCED)</li>
                    <li>PCIe/NVMe</li>
                    <li>SCSI SANITIZE</li>
                </ul>

                <h3>Software</h3>
                <ul>
                    <li>US DoD 5220.22-M and other wipe methodologies</li>
                    <li>Free space (HDD only, past files)</li>
                </ul>

                <aside class="notes">
                    Hardware == whole disk,<br/>
                    software == whole or single file
                </aside>
            </section>

            <section>
                <h2>When a file is deleted</h2>
                <p>It's just marked as so in filesystem &</p>
                <p>On HDD it can be now overwritten by the system</p>
                <p>On SSD - (╯°□°）╯︵ ┻━┻</p>
            </section>

        </section>

        <section>
            <section>
                <h2>HDD sanitization</h2>
                <ul>
                    <li>Blocks, sectors, LBA</li>
                    <li>Talking with controller</li>
                    <li>Manufacturer sanitization</li>
                    <li>Software shredding</li>
                </ul>

                <aside class="notes">
                    LBA == Logical block addressing
                    HDD == Hard Disk Drive
                    SSD == Solid
                </aside>
            </section>

            <section>
                <h2>Blocks, sectors, LBA</h2>
                <ul>
                    <li>In a magnetic drive OS has the direct access to physical sectors. That translates directly to
                        filesystem. i.e. Logical == Physical
                    </li>
                    <li>Typical sector size: 512B in the past, now 4kB</li>
                    <li>Blocks == minimal information chunks size on FS.<br/>Shouldn't be lower than drive sector</li>
                </ul>
                <pre>
                    <code data-trim data-noescape>
                        blockdev --getbsz /dev/nvme0n1
                        fdisk -l | grep "Sector size"
                    </code>
                </pre>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: Controller stuff, intro</h2>
                <p>We'll be using <u>hdparm</u> and <u>smartctl</u> a lot. Let's get used to them. First, let us analyze
                    a typical output</p>
                <pre class="bash">
                    <code>
                        hdparm -I /dev/sda
                        smartctl -a /dev/sda
                    </code>
                </pre>

                <aside class="notes">
                    https://en.wikipedia.org/wiki/SCSI_command && T13-spec from assets
                </aside>
            </section>

            <section>
                <h2>Controller stuff: HPA, DCO</h2>
                <p>Fun stuff you probably haven't heard off</p>
                <p>HPA == host protected area</p>
                <p>DCO == Device configuration overlay</p>

                <p>Those hide sectors from bios/efi, system and user</p>
                <p>(survives everything but secure erase)</p>

                <pre class="bash">
                    <code data-trim>
                        # Your OS may ignore this already
                        cat /sys/module/libata/parameters/ignore_hpa
                    </code>
                </pre>

            </section>

            <section>
                <h2 class="r-fit-text">Controller stuff: Hardware password</h2>
                <p>Master password == for IT admins, higher order*</p>
                <p>User password == self explanatory</p>
                <p>We'll be using <i>hdparm</i> for that</p>
                <small>*- depends on security mode (high or max), let me show you</small>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: set hardware password</h2>
                <p><u>Remember</u> and <u>double-check</u> the password otherwise you'll brick the drive</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        hdparm --user-master u --security-set-pass pass /dev/sda
                        # unplug drive, plug in again, notice that kernel throws read errors!
                        dmesg -c
                        # Notice, that drive now appears locked!
                        hdparm -I /dev/sda
                        # unlock the device
                        hdparm --user-master u --security-unlock pass /dev/sda
                        mount /dev/sda1 /mnt/something
                        dmesg -c
                        hdparm --user-master u --security-disable pass /dev/sda
                        # unplug, plug in again. Now there should be no password left
                        dmesg -c
                    </code>
                </pre>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: when drive is frozen</h2>
                <pre>
                    <code data-trim>
                        # Suspend and wake up
                        echo -n mem > /sys/power/state
                    </code>
                </pre>
                <p>or hotplug SATA</p>
                <p>(AHCI must be enabled for SATA hotplugging)</p>
            </section>

            <section id="manufacturer-sanitization">
                <h2>Manufacturer sanitization</h2>
                <p>Be warned, this takes time</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        # We need to set password first
                        $ hdparm --user-master u --security-set-pass pass /dev/sda

                        # Then wipe
                        $ hdparm --user-master u --security-erase-enhanced pass /dev/sda

                        $ hdparm --security-help

                        ATA Security Commands:
                         Most of these are VERY DANGEROUS (͡° ͜ʖ ͡°) and can destroy all of your data!
                         Due to bugs in older Linux kernels, use of these commands may even
                         trigger kernel segfaults or worse.  EXPERIMENT AT YOUR OWN RISK! ᕕ( ͡°ᴥ ͡°)ᕗ

                         --security-freeze           Freeze security settings until reset.

                         --security-set-pass PASSWD  Lock drive, using password PASSWD:
                                                          Use 'NULL' to set empty password.
                                                          Drive gets locked if user-passwd is selected.
                         --security-prompt-for-password   Prompt user to enter the drive password.

                         --security-unlock   PASSWD  Unlock drive.
                         --security-disable  PASSWD  Disable drive locking.
                         --security-erase    PASSWD  Erase a (locked) drive.
                         --security-erase-enhanced PASSWD   Enhanced-erase a (locked) drive.

                         The above four commands may optionally be preceded by these options:
                         --security-mode  LEVEL      Use LEVEL to select security level:
                                                          h   high security (default).
                                                          m   maximum security.
                         --user-master    WHICH      Use WHICH to choose password type:
                                                          u   user-password (default).
                                                          m   master-password
                    </code>
                </pre>
            </section>

            <section>
                <h2>Software shredding</h2>
                <p>As the OS has direct access to physical sectors we could just..</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        # -u; deallocate and remove file after overwriting
                        # -z; --zero; add a final overwrite with zeros to hide shredding
                        shred -zu /some/file
                    </code>
                </pre>
                <p class="r-fit-text">It's their own algorithm, described in sources. Self-tested with oscilloscope</p>
                <p class="r-fit-text">https://git.savannah.gnu.org/cgit/coreutils.git/tree/src/shred.c#n626</p>
            </section>
        </section>


        <section>
            <section>
                <h2>SSD low level</h2>
                <ul>
                    <li>blocks, pages</li>
                    <li>FTL</li>
                    <li>GC process (P/E Cycle)</li>
                    <li>TRIM (SAS: UNMAP, PCIe: DEALLOCATE)</li>
                </ul>

                <aside class="notes">
                    FTL == Flash Translation Layer, i.e. controller
                </aside>
            </section>

            <section>
                <h2>How data is stored</h2>
                <p class="r-fit-text">Reads pages, erases blocks, writes to empty pages</p>
                <p>blocks: 256kB-4MB, pages: 2-32kB</p>
                <p>Typically 128 pages per block with 4kB page size</p>
                <img class="max300" src="assets/ssd_blocks_pages.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section>
                <h2>Flash Translation Layer</h2>
                <p>i.e. controller operations</p>
            </section>

            <section>
                <h2>Over-provisioning</h2>
                <p>Reserved for controller, rest available to host</p>
                <p class="fragment">Used for:</p>
                <p class="fragment">Garbage collection</p>
                <p class="fragment">Wear leveling</p>
                <p class="fragment">TRIM</p>
                <p class="fragment">Background manufacturer-specific tasks</p>
            </section>

            <section>
                <h2>Garbage collection</h2>
                <img src="assets/hdd_ssd_write_1.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section data-menu-title="Garbage collection 2">
                <h2>Garbage collection</h2>
                <img src="assets/hdd_ssd_write_2.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section data-menu-title="Garbage collection 3">
                <h2>Garbage collection</h2>
                <img src="assets/hdd_ssd_write_3.png"/>
                <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
            </section>

            <section data-menu-title="TRIM">
                <img class="max600" src="assets/ssd_trim.png"/>
                <small>TRIM[2], an ATA/PCIe SSD GarbageCollect extension command</small>

                <aside class="notes">
                    Filesystem needs to support TRIM!
                </aside>
            </section>

        </section>

        <section>
            <section>
                <h2>SSD sanitization</h2>
                <ul>
                    <li>hdd methods ineffective (unfortunate!)</li>
                    <li>dumping flash is easier(& cheaper) than magnetic</li>
                    <li>Talking with controller, again ;)</li>
                </ul>
            </section>

            <section>
                <h2 class="r-fit-text">Do HDD Sanitization methods work well on SSDs?</h2>
                <ul>
                    <li>Degaussing? <span class="fragment">Nope</span></li>
                    <li>Single file overwrite? <span class="fragment">Nope</span></li>
                    <li>Multiple disk overwrites? <span class="fragment">Nope</span></li>
                </ul>
                <p class="fragment">
                    <img class="max300" src="assets/ssd_overwrite_recovery.png"/>
                    <small class="left">Source: [1] M. Wei et al. - Reliably erasing SSDs</small>
                </p>
            </section>

            <section data-menu-title="Physical Access SSD">
                <img class="max550" src="assets/passd.png"/>
                <span class="r-fit-text">IEEE Access, D. Lee et al. October 2020, Improving Write Performance Through Reliable Asynchronous Operation in Physically-Addressable SSD</span>
                <aside class="notes">
                    Patent publication by Google, discarded (first published 2011)
                    Now samsung is trying its best on the topic
                </aside>
            </section>

            <section data-menu-title="FPGA dumper">
                <img src="assets/fpga.png" class="max550"/>
                <p>Fpga flash dumper</p>
            </section>

            <section>
                <h2>Hands on: SATA SSD</h2>
                <p>Closely related to HDD controller stuff from before, though we have more options in this case</p>
                <p>Btw. BIOS/EFI nowadays has secure erase optionm no need to fully boot</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        hdparm -I /dev/sda | egrep -i "erase|sanitize|format|crypt"
                        blkdiscard --verbose [--secure]
                        # Other ATA commands are the same as in case of HDD
                        # see next slide
                    </code>
                </pre>
                <a href="#/manufacturer-sanitization">Back to "Manufacturer sanitization"</a>
            </section>

            <section>
                <h2>Hands on: SATA SSD 2</h2>
                <pre>
                    <code data-trim data-noescape class="nohighlight">
                        # hdparm -I /dev/sda | egrep -i "erase|sanitize|format|crypt"
                               *	SANITIZE_ANTIFREEZE_LOCK_EXT command
                               *	SANITIZE feature set
                               *	CRYPTO_SCRAMBLE_EXT command
                               *	BLOCK_ERASE_EXT command
                               *	Device encrypts all user data
                                supported: enhanced erase
                            2min for SECURITY ERASE UNIT. 2min for ENHANCED SECURITY ERASE UNIT.

                        # hdparm --yes-i-know-what-i-am-doing --sanitize-crypto-scramble /dev/sda

                        /dev/sda:
                        Issuing SANITIZE_CRYPTO_SCRAMBLE command
                        Operation started in background
                        You may use `--sanitize-status` to check progress

                        # hdparm --sanitize-status /dev/sda

                        /dev/sda:
                        Issuing SANITIZE_STATUS command
                        Sanitize status:
                            State:    SD0 Sanitize Idle
                            Last Sanitize Operation Completed Without Error
                    </code>
                </pre>
            </section>

            <section>
                <h2>Hands on: PCIe NVMe SSD</h2>
                <pre class="bash">
                    <code data-trim data-noescape>
                        nvme list
                        nvme id-ctrl /dev/nvme0n1 -H | grep -v " Not Supported" | egrep --color "Sanitize|Format|Erase"
                        man 1 nvme-format
                        # DON'T! Not on your employee laptops anyway
                        nvme format /dev/nvme0n1 -s 1 -n 1
                        nvme format /dev/nvme0n1 -s 2 -n 1
                    </code>
                </pre>
            </section>

        </section>

        <section>
            <section>
                <h2 class="r-fit-text">Special flash case: memory sticks</h2>
                <p>Protocols</p>
                <p>Talking with controller?? Or not ;(</p>
            </section>

            <section>
                <h2>Protocols</h2>
                <p class="r-fit-text">Previously mass storages were using BOT (Bulk-only transport)</p>
                <p class="r-fit-text">Nowadays it was(should be?) superseded by UAS/UASP</p>
                <p>i.e. USB Attached SCSI (Protocol)</p>
                <p>SCSI == Small Computer System Interface ノ( ゜-゜ノ)</p>
            </section>

            <section>
                <h2>Hands on: first impression</h2>
                <p>Run these few commands, try <u>different</u> thumb drives</p>
                <pre>
                    <code data-trim data-noescape>
                        sudo dmesg -c
                        # plug in
                        sudo dmesg -c
                        lsusb
                        # example: Bus 004 Device 004: ID 13fe:5200 Kingston [...]
                        lsusb -d 13fe:5200 -v
                        hdparm -I /dev/sda  # Assuming sda was assigned
                        smartctl -a /dev/sda
                        # plug out
                        sudo dmesg -c
                    </code>
                </pre>
            </section>

            <section>
                <h2>Hands on: if first impressions were bad</h2>
                <p>change usb driver from uas to bot ;)</p>
                <pre class="bash">
                    <code data-trim data-noescape>
                        lsusb -t  # check driver here, usb_storage or uas
                        lsusb
                        # example: Bus 004 Device 007: ID 090c:1000 Silicon Motion [...]
                        echo "090c:1000:u" > /sys/module/usb_storage/parameters/quirks

                        # https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html
                        #     ---> usb-storage.quirks
                    </code>
                </pre>
                <p>And try again</p>
            </section>

            <section>
                <h2>Hands on: wireshark time</h2>
                <pre class="bash">
                    <code data-trim data-noescape>
                        sudo dmesg -c
                        # Requires relogging
                        sudo adduser $USER wireshark
                        sudo dpkg-reconfigure wireshark-common
                        modprobe usbmon
                        sudo setfacl -m u:$USER:r /dev/usbmon*
                        lsusb
                        # example: Bus 004 Device 004: ID 13fe:5200 Kingston [...]
                        # so then run capture on usbmon4
                        # ----> IMPORTANT: notice SCSI dumps !
                    </code>
                </pre>
            </section>

            <section>
                <h2>Summing up the USB stuff</h2>
                <p>Can we talk with flash controller?</p>
                <p><span class="fragment">Well yes</span> <span class="fragment">...but no ;/</span></p>
                <p class="fragment r-fit-text">Manufacturers smart & scsi is implementation is rather poor</p>
                <p class="fragment r-fit-text">Let me show you a few examples on different pendrives</p>
                <p class="fragment r-fit-text">Exception to the rule: SSD over USB sticks, i.e. SAT (USB SATA
                    bridge)</p>
                <small class="fragment">(Example: SanDisk Extreme Pro 128GB stick). Btw. I just bricked it (ಥ﹏ಥ)</small>
            </section>
        </section>

        <section>
            <section>
                <h2>A few drive curiosities</h2>
                <p>Boost HDD performance</p>
                <p>S.M.A.R.T. saving lives, kind of</p>
            </section>

            <section>
                <h2>Boosting HDD seek time</h2>
                <h3>Db-admin secret ^_^</h3>
                <img class="max450" src="assets/header_overview.png"/>
            </section>

            <section>
                <h2>S.M.A.R.T. saving lives</h2>
                <p>Plugged SSD-based pendrive into laptop</p>
                <p class="r-fit-text">Plasma5 notice appeared! "Hey, your disk is gonna die"</p>

                <p>Note to self: show smart of bricked pendrive</p>
                <a class="r-fit-text" target="_blank"
                   href="https://www.backblaze.com/blog/what-smart-stats-indicate-hard-drive-failures/">(I
                    wholeheartedly recommend reading this article from BackBlaze.com)</a>
            </section>
        </section>

        <section>
            <section>
                <h2>Luks intro</h2>
                <ul>
                    <li><span class="r-fit-text">Transparent block cryptography based on linux device mapper</span></li>
                    <li><span class="r-fit-text">Currently two parallel version available: luks1 & luks2</span></li>
                    <li>Many unlock possibilities; for example:
                        <ol>
                            <li>Password or key</li>
                            <li>SSH</li>
                            <li>Pendrive with key during pre-boot</li>
                            <li>Smart card</li>
                            <li>New stuff: TPM - Trusted Platform Module</li>
                        </ol>
                    </li>
                    <li>OFC, <a href="https://en.wikipedia.org/wiki/Comparison_of_disk_encryption_software"
                                target="_blank">there are alternatives</a></li>
                </ul>

                <aside class="notes">
                    Though luks is my personal preference<br />
                    Mention multiple layers of crypto! Possible deniability there.
                </aside>
            </section>

            <section>
                <h2>Hands on: Luks benchmark</h2>
                <pre>
                    <code data-trim data-noescape>
                        $ cat /proc/cpuinfo | grep "model name" | uniq
                        model name	: AMD Ryzen 7 4700U with Radeon Graphics

                        $ cryptsetup benchmark
                        # Tests are approximate using memory only (no storage IO).
                        PBKDF2-sha1      1533005 iterations per second for 256-bit key
                        PBKDF2-sha256    2892623 iterations per second for 256-bit key
                        PBKDF2-sha512    1424695 iterations per second for 256-bit key
                        PBKDF2-ripemd160  740519 iterations per second for 256-bit key
                        PBKDF2-whirlpool  657826 iterations per second for 256-bit key
                        argon2i       4 iterations, 1048576 memory, 4 parallel threads (CPUs) for 256-bit key (requested 2000 ms time)
                        argon2id      4 iterations, 1048576 memory, 4 parallel threads (CPUs) for 256-bit key (requested 2000 ms time)
                        #     Algorithm |       Key |      Encryption |      Decryption
                                aes-cbc        128b      1113.3 MiB/s      3096.0 MiB/s
                            serpent-cbc        128b       111.7 MiB/s       699.9 MiB/s
                            twofish-cbc        128b       231.6 MiB/s       413.6 MiB/s
                                aes-cbc        256b       895.3 MiB/s      2662.2 MiB/s
                            serpent-cbc        256b       117.6 MiB/s       697.4 MiB/s
                            twofish-cbc        256b       238.7 MiB/s       412.7 MiB/s
                                aes-xts        256b      2602.4 MiB/s      2596.9 MiB/s
                            serpent-xts        256b       604.2 MiB/s       604.6 MiB/s
                            twofish-xts        256b       377.6 MiB/s       381.1 MiB/s
                                aes-xts        512b      2265.6 MiB/s      2269.9 MiB/s
                            serpent-xts        512b       616.0 MiB/s       604.5 MiB/s
                            twofish-xts        512b       381.8 MiB/s       380.8 MiB/s
                    </code>
                </pre>

                <aside class="notes">
                    Mention: ciphers, hash mode
                </aside>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: Create your first Luks</h2>

                <pre>
                    <code data-trim data-noescape>
                        fallocate -l 100M test0
                        losetup -f test0
                        # let's assume, we've got assigned loop0
                        cryptsetup luksFormat /dev/loop0
                        cryptsetup luksOpen /dev/loop0 crypt0
                        mkfs.ext4 /dev/mapper/crypt0
                        mkdir /mnt/crypt0 ; mount /dev/mapper/crypt0 /mnt/crypt0
                        echo "my first crypto whatever" > /mnt/crypto/it_works.txt
                        # Hurray!
                        cryptsetup luksDump /dev/loop0
                    </code>
                </pre>

                <aside class="notes">
                    @/etc/modprobe.d/more_loopz.conf:<br/>
                    options loop max_loop=123<br/><br/>

                    mknod /dev/loopX b 7 X<br/>
                    chown --reference=/dev/loop0 /dev/loopX<br/>
                    chmod --reference=/dev/loop0 /dev/loopX<br/>
                    <br/><br/>or just use -f flag... creates those automatically ;)
                </aside>
            </section>

            <section>
                <aside class="notes">
                    luks2 - kernel keyring<br/><br/>

                    header ref<br/>
                    https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup + file in assets for
                </aside>

                <h2 class="r-fit-text">Hands on: luks1 & 2 header + hex view</h2>
                <p>Pro tip, never allocate luks on zeroed medium</p>
                <small>(Like we do here - for better hex analysis)</small>
                <pre>
                    <code data-trim data-noescape>
                        # Steps like before, but!
                        cryptsetup luksFormat /dev/loop1
                        cryptsetup luksFormat --type luks1 /dev/loop2
                        cryptsetup luksFormat --type luks1 -c aes-cbc-essiv:sha256 -h sha1 /dev/loop3
                        cryptsetup luksDump /dev/loop1
                    </code>
                </pre>
                <br/><small>Note to self: okteta / hexdump</small>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: Lul. it wasn't the police</h2>
                <pre class="sh max100">
                    <code data-trim data-noescape>
                        cryptsetup erase /dev/loop0  # Yup, that's all.
                        # or brick the header:
                        dd if=/dev/urandom of=/dev/sdb1 bs=1M count=4 conv=sync
                        # Now check
                        cryptsetup luksDump /dev/loop0 # No keyslots !
                        # https://www.kernel.org/doc/html/v4.10/admin-guide/sysrq.html
                        # Will immediately reboot the system without syncing or unmounting your disks.
                        echo b > /proc/sysrq-trigger
                    </code>
                </pre>
                <img class="max450" src="assets/scream2.jpg"/>

                <aside class="notes">
                    Mention luksSuspend - it deletes key from memory.
                </aside>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: Howto recover keyslot</h2>
                <img class="max500" src="assets/kono_healer_mendokusai.png"/>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: Howto recover keyslot</h2>
                <p>Ofc you could just back the header up beforehand...</p>
                <pre class="sh">
                    <code data-trim data-noescape>
                        cryptsetup luksHeaderBackup --header-backup-file luks_header.bin /dev/loop1
                        file luks_header.bin
                        # --> luks_header.bin: LUKS encrypted file, ver 2 [, , sha256] UUID: XXXXXXXXXXXXXXXXXX
                        # And then restore
                        cryptsetup luksHeaderRestore --header-backup-file luks_header.bin /dev/loop1
                        # Oh, or just the master key (you'll see why in a second)
                        cryptsetup luksDump -q --dump-master-key /dev/loop1 > master.key.dump
                        cat master.key.dump | grep -A 3 'MK dump' | sed -e 's/MK dump://g' -e 's/\s//g' | xxd -r -p > master.key
                    </code>
                </pre>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: Howto recover keyslot</h2>
                <p>But there is a way! (If luks is still mapped)</p>
                <pre class="sh">
                    <code data-trim data-noescape>
                        dmsetup table /dev/mapper/test --showkeys
                        # Yup, master key is still in memory. Let's grab it
                        cryptsetup luksAddKey /dev/loop2 --master-key-file <(dmsetup table --showkey /dev/mapper/test2 | awk '{print$5}' | xxd -r -p)
                        Enter new passphrase for key slot:
                        Verify passphrase:

                        # Wohoooooo! Saved
                    </code>
                </pre>
            </section>

            <section>
                <h2>Nuke it with predefined password :*</h2>
                <pre>
                    <code data-trim data-noescape>
                        dpkg-reconfigure cryptsetup-nuke-password
                        # now your boot is armored with fake password

                        # When you'll be quitting your job... just type it in ;)
                        # It erases luks key slots
                    </code>
                </pre>
            </section>

            <section>
                <h2>Hollywood-style-raid & forensics</h2>
                <ol>
                    <li>Arrive with liquid nitrogen and external battery PSU</li>
                    <li class="fragment">Stabilize power</li>
                    <li class="fragment">Freeze RAM</li>
                    <li class="fragment">Either boot mini-OS or move sticks to another machine</li>
                    <li class="fragment">Attach write blocker to disk, dump</li>
                    <li class="fragment">Do forensics™ on disk clone</li>
                </ol>
            </section>

            <section>
                <h2>And the thing with RAM is..</h2>
                <img src="assets/ram_fading.png"/>
                <small>Source: A. Halderman et al. - Lest We Remember: Cold Boot Attacks on Encryption Keys</small>
            </section>

            <section>
                <h2>Luks problems</h2>
                <p>You need TPM, Secure boot & signed kernels (gain root of trust). Required to mitigate /boot
                    poisoning</p>
                <p>RAM dump == your key is retrieved</p>
                <p class="r-fit-text">Without truly wiped SSD keys are <strike>easily</strike> cheaply retrievable</p>
                <p>Higher density drives give you a higher "chance of survival"</p>
            </section>

            <section>
                <h2>Let's do the reverse,<br/>now we crack luks</h2>
            </section>

            <section>
                <h2 class="r-fit-text">Hands on: Cracking luks - attempt 1</h2>
                <pre>
                    <code class="shell" data-trim data-noescape>
                        git clone https://github.com/cryptcoffee/skul
                        cd skul ; ./configure ; make skul
                        ./skul disks/test_disk_py
                    </code>
                </pre>

                <pre>
                    <code class="nohighlight" data-trim data-noescape>
                                 --[ CRYPTCOFFEE ]--

                              ██████  ██ ▄█▀ █    ██  ██▓
                            ▒██    ▒  ██▄█▒  ██  ▓██▒▓██▒
                            ░ ▓██▄   ▓███▄░ ▓██  ▒██░▒██░
                              ▒   ██▒▓██ █▄ ▓▓█  ░██░▒██░
                            ▒██████▒▒▒██▒ █▄▒▒█████▓ ░██████▒
                            ▒ ▒▓▒ ▒ ░▒ ▒▒ ▓▒░▒▓▒ ▒ ▒ ░ ▒░▓  ░
                            ░ ░▒  ░ ░░ ░▒ ▒░░░▒░ ░ ░ ░ ░ ▒  ░
                            ░  ░  ░  ░ ░░ ░  ░░░ ░ ░   ░ ░
                                  ░  ░  ░      ░         ░  ░

                        Disk UUID:         6b552406-c2bf-441e-a451-f8cfd8c3f1e2
                        Magic:             LUKS 0xba 0xbe
                        Version:           1
                        Cipher name:       aes
                        Cipher mode:       cbc-essiv:sha256
                        Hash spec:         sha1
                        Master key len:    32 byte (256 bit)
                        Master key digest: d7 a1 59 78 c3 cb 06 a1 cb 22 19 7b a6 bb 1f 0c 43 5c 9e da
                        Master key salt:   24 d3 e4 84 72 74 f3 ec 3e 34 e9 dd 84 48 2e f7
                                           64 77 5d 3b 13 57 0d 17 0f d1 81 09 24 c5 5a 08
                        Iterations:        7375

                        KEYSLOTS:

                        KEYSLOT 0: ACTIVE
                            Iterations:            29667
                            Salt:                  fb d6 c9 13 1e de 7e 42 32 70 ff 45 6f 86 51 1d
                                                   31 75 7c b1 1e d8 7a 37 77 31 3b 95 f7 29 61 9b
                            Key material offset:   8 sectors
                            Stripes:               4000
                        KEYSLOT 1: INACTIVE
                        KEYSLOT 2: INACTIVE
                        KEYSLOT 3: INACTIVE
                        KEYSLOT 4: INACTIVE
                        KEYSLOT 5: INACTIVE
                        KEYSLOT 6: INACTIVE
                        KEYSLOT 7: INACTIVE

                        Threads:     8
                        Fast check:  Enabled
                        Attack mode: Password List first, then Bruteforce

                        Settings for Bruteforce:
                        Min len:     2 characters
                        Max len:     6 characters
                        Alphabet:    1

                        Press enter to start cracking!

                        Attacking keyslot: 0
                        Password list: 306308 passwords
                        Tried: 306308    100%
                        Password not found
                        Time: 00:17:24

                        Bruteforce: 2 chars
                        Tried: 599        88%

                        Password found!!
                        Keyslot: 0
                        The password is: py

                        TOTAL TIME: 00:17:26
                    </code>
                </pre>
            </section>

            <section>
                <h2>Hands on: bruteforce luks</h2>
                <pre>
                    <code data-trim>
                        $ bruteforce-luks -t 4 -l 3 -m 4 -s abcdefgh -v 15 /dev/loop2
                        Tried / Total passwords: 1 / 4608
                        Tried passwords per second: 0.500000
                        Last tried password: aae
                        Total space searched: 0.021701%
                        ETA: Tue 06 Dec 2022 10:35:56 AM CET

                        Password found: aaa
                    </code>
                </pre>
            </section>

            <section>
                <h2>Luks homework</h2>
                <p class="r-fit-text">cryptsetup luksFormat --type luks1 -c aes-cbc-essiv:sha256 -h sha1 _device_</p>
                <p>Break it with john the ripper or hashcat. <br/>This config highly suspectivle to brute force</p>
                <pre>
# ./apps/john-bleeding-jumbo/run/luks2john.py luks2
luks2 : Only LUKS1 is supported. Used version: 2

# ./apps/john-bleeding-jumbo/run/luks2john.py luks1
luks1 : Only cbc-essiv:sha256 mode is supported.
Used mode: b'xts-plain64\x00\x00\x00\x00[...]\x00\x00\x00\x00\x00\x00'
                </pre>
                <span>(ノಠ益ಠ)ノ彡┻━┻</span>
            </section>
        </section>

        <section>
            <section>
                <h2>Time to automate...</h2>
                <p>Dbus!</p>
                <p>Triggers</p>
            </section>

            <section>
                <h2>Dbus</h2>
                <img class="max550" src="assets/wikipedia_dbus.png"/>
            </section>

            <section>
                <h2>Sample dbus client</h2>
                <small>https://github.com/rikkt0r/presentations/tree/main/drive-crypt</small>
                <pre>
                    <code data-trim data-noescape>
                        #!/usr/bin/python3
                        from collections import namedtuple

                        import dbus
                        from gi.repository import GLib
                        from dbus.mainloop.glib import DBusGMainLoop

                        Notification = namedtuple("Notification", [
                            "app_name",
                            "replaces_id",
                            "app_icon",
                            "summary",
                            "body",
                            "actions",
                            "hints",
                            "expire_timeout"
                        ])

                        def print_notification(bus, message):
                            args = message.get_args_list()
                            if len(args) == 8:
                                notification = Notification(*args)
                                print(f'{notification.app_name} :::: {notification.summary} - {notification.body}')
                            else:
                                print("Unparsable", args)


                        if __name__ == "__main__":
                            loop = DBusGMainLoop(set_as_default=True)
                            session_bus = dbus.SessionBus()
                            session_bus.add_match_string(
                                "type='method_call',interface='org.freedesktop.Notifications',member='Notify',eavesdrop=true")
                            session_bus.add_message_filter(print_notification)
                            GLib.MainLoop().run()


                        """Run output:
                        Spotify :::: Better Place - Super Flu Remix - Godford - Better Place (Super Flu Remix)
                        Spotify :::: Hiding - Hidden Empire - Hiding
                        Spotify :::: Cappadocia - Ben Böhmer - Cappadocia
                        Spotify :::: How Often - Ben Böhmer Remix - Lane 8 - Brightest Lights Remixed
                        Spotify :::: Yahyel - Morttagua - Yahyel
                        Spotify :::: Subjection - Submelody - Subjection
                        Spotify :::: Lost In You - Marsh - Lost In You EP
                        Spotify :::: Ascendance - Eynka - Ascendance / Give It Up
                        Spotify :::: Unite - Yeadon - Unite
                        Spotify :::: Breathe Out - Just Her - Beautiful Nothing EP
                        Spotify :::: White Ghost - J_ulio - Far Away Connections
                        Plasma Workspace :::: Gwenview Closed Unexpectedly - Please report this error to help improve this software.
                        Signal :::: Sąsiadka Katarzyna - Video
                        Network Management :::: pvpn-ipv6leak-protection - Connection 'pvpn-ipv6leak-protection' activated.
                        Network Management :::: pvpn-ipv6leak-protection - Connection 'pvpn-ipv6leak-protection' activated.
                        Network Management :::: Proton VPN CH#41 - VPN connection 'Proton VPN CH#41' activated.
                        Network Management :::: Proton VPN CH#41 - VPN connection 'Proton VPN CH#41' activated.
                        """
                    </code>
                </pre>
            </section>

            <section>
                <h2>TODO Sample dbus notification spawn</h2>
                <a href="https://github.com/rhinstaller/dasbus" target="_blank">Server here</a>
            </section>

            <section>
                <h2>Hands on: Your turn</h2>
                <p>Run the script, notice what happens</p>
                <small>Side node: for final script we're gonna use SystemBus, not SessionBus</small>
            </section>

        </section>

        <section>
            <section>
                <h2>Wet dream of a crypto-nerd</h2>
                <p>Let's create YOUR opus magnum of cryptography</p>
                <p>(Well, without possible deniability)</p>
                <p class="fragment">why do this you ask?</p>
            </section>

            <section data-menu-title="FBI Raid">
                <img src="assets/fbi-open-up-fbi-meme.gif"/>
                <h2>Coz this happens..</h2>
            </section>

            <section data-menu-title="FBI Raid goes on">
                <img src="assets/fbi-swat.gif"/>
                <h2>.. and then that</h2>
                <h3>Gotta act fast ✌</h3>
            </section>

            <section>
                <h2>The master-plan</h2>
                <p>Choose your favourite sanitization methods</p>
                <p>Create luks on top of that</p>
                <p>Add a sprinkle of magic</p>
                <p>Call the police (´・ω・)っ由</p>
                <img src="assets/fbi-anime.gif"/>
            </section>

            <section>
                <h2>Open workshop</h2>
                <p>Creating opus magnum of crypto</p>
                <p class="r-fit-text">Remember - Be dual? triple? <u>OCTA-SURE about wiping keys!</u></p>
                <img class="fragment fade-in-then-out" src="assets/fbi-fbi-typing.gif"/>
                <p class="r-fit-text fragment">Current presentation for reference:<br/>https://github.com/rikkt0r/presentations/tree/main/drive-crypt
                </p>
            </section>
        </section>

        <section data-menu-title="Tin foil hat ideas">
            <h2 class="r-fit-text">TIN FOIL HAT IDEAS ┬─┬ ︵ /(.□. \）</h2>
            <ul>
                <li><span class="r-fit-text">For how long the key is recoverable from disk eeprom?</span></li>
                <li>Ram is alive for some time after power down, so...</li>
                <li>Ram: Use BIOS POST (Power-On Self Test)</li>
                <li><span class="r-fit-text">Ram: TRESOR: TRESOR Runs Encryption Securely Outside RAM</span></li>
                <li><span class="r-fit-text">RamCrypt: Kernel-based Address Space Encryption for User-mode Processes
                </span></li>
                <li><span class="r-fit-text" style="padding-top: 10px;">Always have a bootable pendrive containing memtest86 plugged-in.<br/> HDD/SSD has higher priority, so that this boots after disk sanitization</span>
                </li>
                <li>Use explosives, lul.</li>
            </ul>
        </section>

        <section>
            <h2>The end; &copy; rikkt0r; @:priv@asap.solutions</h2>
            <p>(づ｡◕‿‿◕｡)づ Bibliography</p>
            <ol>
                <li><a class="r-fit-text" href="https://www.usenix.org/legacy/events/fast11/tech/full_papers/Wei.pdf"
                       target="_blank">[Usenix]
                    Reliably Erasing Data From Flash-Based Solid State Drives</a></li>
                <li><a target="_blank" href="https://www.techtarget.com/searchstorage/definition/TRIM">[Techtarget®]
                    Nice TRIM
                    definition</a></li>
                <li><a target="_blank" href="https://www.smartmontools.org/wiki/USB">SCSI/ATA/SATA -> USB adapter
                    support</a></li>
                <li><a target="_blank" href="https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase">[Kernel wiki] ATA
                    Secure erase</a>
                </li>
                <li>manpages for: smartmontools, hdparm, nvme-cli</li>
                <li><a href="https://diverto.github.io/2019/11/18/Cracking-LUKS-passphrases">[github->diverto] Cracking
                    Luks passphrases</a>
                </li>
                <li>& everything in assets/ directory to this presentation</li>
            </ol>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script src="plugin/menu/menu.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMenu ]
    });


</script>
</body>
</html>
